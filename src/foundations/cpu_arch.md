# CPU 微架构原理 (CPU Microarchitecture)

在高频交易面试中，面试官经常会问：“为什么 if 语句会慢？”或者“什么是分支预测失败？”。如果不理解 CPU 的工作原理，你就无法编写出真正榨干硬件性能的代码。

本章将深入 CPU 内部，解释流水线、分支预测和乱序执行等核心概念。理解这些，是成为 HFT 开发者的第一步。

## 1. 指令流水线 (Instruction Pipeline)

想象一家汽车组装工厂。如果不使用流水线，工人们必须先造完底盘，再装引擎，再装轮胎，最后喷漆，然后才能开始造下一辆车。这显然效率极低。

现代 CPU 也是如此。执行一条指令并不是瞬间完成的，它通常分为以下几个阶段（以经典的 5 级流水线为例）：

1.  **取指 (Fetch, IF)**: 从内存（或 L1 指令缓存）中读取指令。
2.  **译码 (Decode, ID)**: 将指令翻译成 CPU 内部的微操作 (uOps)。
3.  **执行 (Execute, EX)**: ALU 进行计算（加减乘除）。
4.  **访存 (Memory, MEM)**: 读写内存数据。
5.  **写回 (Writeback, WB)**: 将结果写回寄存器。

### 1.1 直观图解：流水线如何工作

假设我们需要执行 3 条独立的指令（A, B, C）。

**无流水线 (Serial Execution):**
每条指令需要 5 个时钟周期。3 条指令总共需要 15 个周期。

```text
Cycle: 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
Instr A: [IF][ID][EX][MEM][WB]
Instr B:                [IF][ID][EX][MEM][WB]
Instr C:                               [IF][ID][EX][MEM][WB]
```

**有流水线 (Pipelined Execution):**
虽然单条指令的延迟（Latency）没有变（仍然需要 5 个时钟周期），但吞吐量（Throughput）变成了每个周期完成 1 条指令。3 条指令只需要 7 个周期！

```text
Cycle: 1  2  3  4  5  6  7
Instr A: [IF][ID][EX][MEM][WB]
Instr B:    [IF][ID][EX][MEM][WB]
Instr C:       [IF][ID][EX][MEM][WB]
```

### 1.2 流水线气泡 (Pipeline Bubble)

但是，如果下一条指令依赖上一条指令的结果（数据依赖），或者遇到跳转指令（控制依赖），流水线就会停顿。这就像前面的工序卡住了，后面的工序只能空等。这种停顿称为“气泡”。

**示例代码：数据依赖**
```rust
let a = 10;
let b = a + 5; // 依赖 a 的值
```

在执行 `b = a + 5` 的 **Execute** 阶段之前，必须等待 `a = 10` 的 **Writeback** 阶段完成（或者通过 Forwarding 技术提前拿到结果）。如果无法通过 Forwarding 解决，流水线就会出现气泡。

```text
Cycle: 1  2  3  4  5  6  7  8
Instr 1 (a=10): [IF][ID][EX][MEM][WB]
Instr 2 (b=a+5):   [IF][ID] .. .. [EX][MEM][WB]  <-- 气泡 (Bubble)
```

## 2. 分支预测 (Branch Prediction)

这是 HFT 中最常被提及的概念。

当 CPU 遇到一个 `if` 语句（条件跳转）时，它面临一个难题：下一条指令在哪里？是 `if` 块里的代码，还是 `else` 块里的代码？
由于流水线的存在，CPU 不能等待条件判断的结果算出来再决定去哪里取指（那会浪费十几个周期）。

**CPU 必须猜测**。

*   **预测正确**: 流水线继续满负荷运转，几乎没有性能损失。
*   **预测失败 (Misprediction)**: 灾难发生。CPU 必须清空整个流水线中所有已经执行但尚未写回的指令（因为它们是基于错误的路径执行的），重新从正确的地址开始取指。这会导致 **15-20 个时钟周期** 的惩罚。

### 2.1 经典案例：有序数组处理更快

这也是为什么处理有序数组往往比处理乱序数组快得多的原因。

```rust
// 假设 data 是随机的
for &x in data.iter() {
    if x > 128 { // 这个分支很难预测，如果是随机数，预测准确率只有 50%
        sum += x;
    }
}
```

如果 `data` 是有序的（如 `0, 1, 2... 255`），那么前一半全是 `false`，后一半全是 `true`。分支预测器可以轻松达到 100% 的准确率。

### 2.2 无分支编程 (Branchless Programming)

为了避免分支预测失败，我们可以使用数学运算或位运算来替代 `if`。

**有分支写法:**
```rust
let y = if x > 0 { 1 } else { 0 };
```
这会生成跳转指令 (`JMP`, `JNE`)，可能导致流水线清空。

**无分支写法:**
```rust
let y = (x > 0) as i32;
```
这会生成条件传送指令 (`CMOV`) 或利用比较指令的结果直接计算。虽然计算量可能稍大（多执行了一条指令），但它**消除了不确定性**，保证了流水线的顺畅。

### 2.3 Rust 中的优化提示

虽然现代 CPU 的分支预测器非常聪明（使用历史表和感知机算法），但在某些极端情况下，我们可以手动给编译器提示。

```rust
#![feature(core_intrinsics)]
use std::intrinsics::{likely, unlikely};

if unsafe { likely(x > 0) } {
    // 编译器会将这段代码放在紧接着跳转指令的位置，优化 I-Cache
    fast_path();
} else {
    slow_path();
}
```

在 Stable Rust 中，我们可以使用 `#[cold]` 属性标记不常用的函数：

```rust
#[cold]
fn handle_error() {
    // 编译器会把这个函数放到比较远的内存区域，避免污染 I-Cache
}
```

## 3. 乱序执行 (Out-of-Order Execution, OoO)

为了掩盖内存访问的高延迟，现代 CPU（如 Intel Skylake, AMD Zen）都是乱序执行的。

如果指令序列是：
1. `A = load(ptr)` (Cache Miss, 需要 300 周期)
2. `B = A + 1` (依赖 A)
3. `C = 5 * 2` (不依赖 A)

如果是顺序执行，CPU 会在第 1 步卡住 300 个周期，第 3 步也被阻塞。
但在乱序执行中，CPU 会有一个 **重排序缓冲区 (Reorder Buffer, ROB)**。它会发现指令 3 不依赖指令 1 和 2，于是先执行指令 3。

### 3.1 数据依赖链 (Data Dependency Chain)

虽然 OoO 很强大，但它无法打破真正的数据依赖。

```rust
// 强依赖链：必须串行执行
a = b + 1;
c = a + 1;
d = c + 1;
```

```rust
// 无依赖：可以并行执行（利用超标量架构）
a = b + 1;
c = e + 1;
d = f + 1;
```

在 HFT 代码中，我们有时会通过**打破依赖链**来提高指令级并行度 (ILP)。

## 4. 超标量 (Superscalar)

现代 CPU 核心通常有多个执行端口（Port）。例如，它可能有两个整数 ALU，两个浮点 FPU，两个加载/存储单元。
这意味着，在理想情况下，CPU 一个周期可以同时发射并执行 4-6 条指令！

这就是为什么 SIMD（单指令多数据）和循环展开（Loop Unrolling）如此有效——它们喂饱了 CPU 的所有执行单元。

## 5. 总结

编写低延迟代码不仅仅是写出逻辑正确的代码，更是要写出**对 CPU 友好**的代码：

1.  **减少分支**: 使用数学运算或位运算代替 `if`（Branchless Programming）。
2.  **提高预测率**: 让分支模式尽可能可预测。
3.  **打破依赖**: 让指令之间尽可能独立，利用 CPU 的乱序执行能力。
4.  **利用流水线**: 保持流水线充盈，避免气泡。

下一章，我们将结合具体的内存知识，讲解 [内存布局与缓存效率](memory_layout.md)。
